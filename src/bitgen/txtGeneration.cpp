/**
 * txtGeneration.cpp - Bitcoin address generator
 *
 * Copyright (C)2015 The bitgen developers <bitgen@openmailbox.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */
 
/**
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE. 
*/


#include "txtGeneration.h"
#include "util.h"
#include "FileUtil.h"
#include "currencySpecific.h"
#include "bigintutil.h"
#include "hash.h"
#include "StaticXor.h"

#include <iostream>










FilePair generateExtendedTxtFiles(const std::string& pub, const std::string priv, 
					const std::string& genMethod, 
					const std::string& thetime, const std::string& accountName,
					const std::string& versionNumber, const std::string& applicationName,
					const std::list<ExtraInfo>& generationExtra,
					const std::string& derivationPath,
					const bool currencySpecific
					)
{
	
	std::string pubTxt;

	if(currencySpecific)
	{
		pubTxt += "Currency         : ";
		const std::string currencyName = getCurrencyName();	
		pubTxt += currencyName;
		pubTxt += "\n";
	}
	
	pubTxt += "Public           : ";
	pubTxt += pub;
	pubTxt += "\n";
	
	pubTxt += "Generated by     : ";
	pubTxt += applicationName;
	pubTxt += " ";
	pubTxt += versionNumber;
	pubTxt += "\n";
	
	pubTxt += "Generation time  : ";
	pubTxt += thetime;
	pubTxt += "\n";
	if(!accountName.empty())
	{
		pubTxt += "Account name     : ";
		pubTxt += accountName;
		pubTxt += "\n";	
	}

	pubTxt += "Derivation path  : ";
	pubTxt += derivationPath;
	pubTxt += "\n";
	
	std::string privTxt(pubTxt);
	
	privTxt += "Private          : ";
	privTxt += priv;
	privTxt += "\n";
	
	privTxt += "Generation method: ";
	privTxt += genMethod;
	privTxt += "\n";

	//privTxt += "Mnemonic         : ";
	//privTxt += mnemonic;
	//privTxt += "\n";

// minSize(std::string str, const int minSize, const bool right = false);


	for(std::list<ExtraInfo>::const_iterator it = generationExtra.begin() ;
		it != generationExtra.end() ;
		++it)
	{
		const ExtraInfo& extra = (*it);
		privTxt += minSize(extra.title, 17);
		privTxt += ": ";
		privTxt += extra.value;
		privTxt += "\n";
		
	}

	//if(!generationExtra.empty())
	//{
	//	privTxt += "\n";
	//}


	FilePair fpair(pubTxt, privTxt);
	return fpair;
}







FilePair generateMnemonicFile(
					const std::string& genMethod, const std::list<ExtraInfo>& generationExtra,
					const std::string& thetime, const std::string& accountName,
					const Mnemonic& mnemonic,
					const std::string& versionNumber, const std::string& applicationName,
					const bool currencySpecific,
					const std::string& xpriv, 
					const std::string& xpub,
					const std::string& derivedPubStrWithExtraInfo,
					const std::string& derivedXpub,					
					const bool includedExtendedAddress)
{
	
	std::string pubTxt;

	if(currencySpecific || !derivedXpub.empty())
	{
		pubTxt += "Currency         : ";
		const std::string currencyName = getCurrencyName();	
		pubTxt += currencyName;
		pubTxt += "\n";
	}
		
	pubTxt += "Generated by     : ";
	pubTxt += applicationName;
	pubTxt += " ";
	pubTxt += versionNumber;
	pubTxt += "\n";
	
	pubTxt += "Generation time  : ";
	pubTxt += thetime;
	pubTxt += "\n";
	if(!accountName.empty())
	{
		pubTxt += "Account name     : ";
		pubTxt += accountName;
		pubTxt += "\n";	
	}

	if(includedExtendedAddress)
	{
		pubTxt += "xpub             : ";
		pubTxt += xpub;
		pubTxt += "\n";

		if(!derivedXpub.empty())
		{
			
			pubTxt += "derived orig xpub: ";
			pubTxt += derivedPubStrWithExtraInfo;
			pubTxt += "\n";
			
			pubTxt += "derived xpub     : ";
			pubTxt += derivedXpub;
			pubTxt += "\n";
		}
	}

	pubTxt += "Num words        : ";
	pubTxt += intToString(mnemonic.numberWords());
	pubTxt += "\n";

	
	std::string privTxt(pubTxt);
	
	privTxt += "Generation method: ";
	privTxt += genMethod;
	privTxt += "\n";

	privTxt += "Mnemonic         : ";
	privTxt += mnemonic.toStr();
	privTxt += "\n";

	if(includedExtendedAddress)
	{
		privTxt += "xpriv            : ";
		privTxt += xpriv;
		privTxt += "\n";
	}


	for(std::list<ExtraInfo>::const_iterator it = generationExtra.begin() ;
		it != generationExtra.end() ;
		++it)
	{
		const ExtraInfo& extra = (*it);
		privTxt += minSize(extra.title, 17);
		privTxt += ": ";
		privTxt += extra.value;
		privTxt += "\n";		
	}

	const FilePair filePair(pubTxt, privTxt);


	return filePair; //privTxt;
}





std::string generateStaticXorFile(const std::string& thetime, 
	const std::string& versionNumber, const std::string& applicationName, 
	const std::string& accountName,
	//const std::string& mnemonic,
	const BigInt<256>& staticXor)
{
	std::string pubTxt;
		
	pubTxt += "Generated by     : ";
	pubTxt += applicationName;
	pubTxt += " ";
	pubTxt += versionNumber;
	pubTxt += "\n";
	
	pubTxt += "Generation time  : ";
	pubTxt += thetime;
	pubTxt += "\n";
	
	if(!accountName.empty())
	{
		pubTxt += "Account name     : ";
		pubTxt += accountName;
		pubTxt += "\n";	
	}

	
	std::string privTxt(pubTxt);

	const std::string staticXorStr = hexString(staticXor.getBinaryLong());	
	
	privTxt += "Static XOR       : ";
	privTxt += staticXorStr;
	privTxt += "\n";
	
	const std::string hash = staticXorHash(staticXor);
	

	privTxt += "Hash             : ";
	privTxt += hexString(hash);
	privTxt += "\n";


	return privTxt;
}






const std::string generatePadTxtFile(//const PubAddress& not_used_pubkey, 
	const std::string& pad, const int padNum, const int totalPads,
	const std::string& genMethod, const std::string& thetime, 
	const std::string& versionNumber, const std::string& applicationName, const std::list<ExtraInfo>& generationExtra,
	const std::string& accountName,
	const std::string& mnemonic,
	const BigInt<256>& staticXor)
{
	std::string pubTxt;

	pubTxt += "Currency         : ";
	const std::string currencyName = getCurrencyName();	
	pubTxt += currencyName;
	pubTxt += "\n";
	
	//pubTxt += "Public address   : ";
	//pubTxt += pubkey.toString();
	//pubTxt += "\n";
	
	//if(getCurrencyShortName() == "bch")
	//{
	//	pubTxt += "Public cashaddr  : ";
	//	pubTxt += pubkey.toCashAddrString();
	//	pubTxt += "\n";		
	//}
	
	pubTxt += "Generated by     : ";
	pubTxt += applicationName;
	pubTxt += " ";
	pubTxt += versionNumber;
	pubTxt += "\n";
	
	pubTxt += "Generation time  : ";
	pubTxt += thetime;
	pubTxt += "\n";
	
	if(!accountName.empty())
	{
		pubTxt += "Account name     : ";
		pubTxt += accountName;
		pubTxt += "\n";	
	}

	
	std::string privTxt(pubTxt);
	
	privTxt += "Private PAD      : ";
	privTxt += hexString(pad);
	privTxt += "\n";
	
	privTxt += "Pad num          : ";
	privTxt += intToString(padNum + 1);
	privTxt += "\n";
	
	privTxt += "Total pads       : ";
	privTxt += intToString(totalPads);
	privTxt += "\n";
	
	const BigInt<256> zero;
	if(staticXor != zero)
	{
		privTxt += "Static XOR hash  : ";
		const std::string hashPart = staticXorHash(staticXor);

		//const std::string hash = doubleSha256(staticXor.getBinaryLong());
		//const std::string hashPart = hash.substr(0, 4);
		privTxt += hexString(hashPart);
		privTxt += "\n";		
	}
	
	privTxt += "Generation method: ";
	privTxt += genMethod;
	if(staticXor != zero)
	{
		privTxt += " with static XOR";
	}
	privTxt += "\n";

	privTxt += "Mnemonic         : ";
	privTxt += mnemonic;
	privTxt += "\n";



	for(std::list<ExtraInfo>::const_iterator it = generationExtra.begin() ;
		it != generationExtra.end() ;
		++it)
	{
		const ExtraInfo& extra = (*it);
		privTxt += minSize(extra.title, 17);
		
		privTxt += ": ";
		privTxt += extra.value;
		privTxt += "\n";
		
	}

	//if(!generationExtra.empty())
	//{
	//	privTxt += "\n";
	//}


	//FilePair fpair(pubTxt, privTxt);
	return privTxt;
}




FilePair generateTxtFiles(const /*std::string*/PubAddress& pubkey, const std::string privateb58, 
					const std::string& genMethod, const std::list<ExtraInfo>& generationExtra,
					const std::string& thetime, const std::string& accountName,
					const std::string& mnemonic, const bool compressed, 
					const std::string& versionNumber, const std::string& applicationName,
					const BigInt<256>& staticXor)
{
	
	std::string pubTxt;

	pubTxt += "Currency         : ";
	const std::string currencyName = getCurrencyName();	
	pubTxt += currencyName;
	pubTxt += "\n";

	if(getCurrencyShortName() != "bch_slp")
	{
		pubTxt += "Public address   : ";
		pubTxt += pubkey.toString();
		pubTxt += "\n";
	}
	
	
	if(getCurrencyShortName() == "bch" || getCurrencyShortName() == "bch_slp")
	{
		pubTxt += "Cash address     : ";
		pubTxt += pubkey.toFullCashAddrString(); //toCashAddrString();
		pubTxt += "\n";
		
		pubTxt += "Cash address read: ";
		pubTxt += pubkey.toCashAddrReadableString();
		pubTxt += "\n";				
	}
	
	pubTxt += "Generated by     : ";
	pubTxt += applicationName;
	pubTxt += " ";
	pubTxt += versionNumber;
	pubTxt += "\n";
	
	pubTxt += "Generation time  : ";
	pubTxt += thetime;
	pubTxt += "\n";
	if(!accountName.empty())
	{
		pubTxt += "Account name     : ";
		pubTxt += accountName;
		pubTxt += "\n";	
	}

	
	std::string privTxt(pubTxt);
	
	privTxt += "Private key (WIF): ";
	privTxt += privateb58;
	privTxt += "\n";
	privTxt += "Compressed       : ";
	privTxt += (compressed ? "yes" : "no");
	privTxt += "\n";
	
	//if(!accountName.empty())
	//{
	//	privTxt += "Account name     : ";
	//	privTxt += accountName;
	//	privTxt += "\n";	
	//}
	privTxt += "Generation method: ";
	privTxt += genMethod;
	const BigInt<256> zero;
	if(staticXor != zero)
	{
		privTxt += " with static xor";
	}
	privTxt += "\n";

	if(staticXor != zero)
	{
		privTxt += "Static xor hash  : ";
		const std::string xorHash = staticXorHash(staticXor);
		privTxt += hexString(xorHash);
		privTxt += "\n";
	}


	privTxt += "Mnemonic         : ";
	privTxt += mnemonic;
	privTxt += "\n";



	for(std::list<ExtraInfo>::const_iterator it = generationExtra.begin() ;
		it != generationExtra.end() ;
		++it)
	{
		const ExtraInfo& extra = (*it);
		privTxt += minSize(extra.title, 17);
		
		privTxt += ": ";
		privTxt += extra.value;
		privTxt += "\n";
		
	}

	//if(!generationExtra.empty())
	//{
	//	privTxt += "\n";
	//}


	FilePair fpair(pubTxt, privTxt);
	return fpair;
}




void saveExtendedTxtFiles(FilePair& txtFiles, const std::string& fileId, const bool currencySpecific, const bool isElectrum)
{	
	std::string currencySpecStr;
	if(currencySpecific || isElectrum)
	{
		currencySpecStr += getCurrencyShortName();
		currencySpecStr += "_";		
	}
	
	const std::string start = isElectrum ? "electrum" : "extended";
	
	const std::string pubFilename = start + "_" + currencySpecStr + fileId + "_share.txt";
	const std::string privFilename = start + "_" + currencySpecStr + fileId + "_private.txt";

	//const std::string fullPrivPath = (privPath == ".") ? privFilename : (privPath + "/" + privFilename);
	std::cout << "Saving priv txt: " << privFilename << std::endl;
	fileWrite(privFilename, txtFiles.privateFile);	

	//const std::string fullPubPath = (pubPath == ".") ? pubFilename : (pubPath + "/" + pubFilename);
	std::cout << "Saving pub txt : " << pubFilename << std::endl;
	fileWrite(pubFilename, txtFiles.publicFile);	
}




void saveOtpFile(const PubAddress& pubkey, const std::string pad, const int indexPad, const int totalPads,
					const std::string& thetime, const std::string privPath,
					const std::string& versionNumber, const std::string& applicationName,
					const std::list<ExtraInfo>& generationExtra, const std::string& accountName,
					const std::string& mnemonic, const std::string& generator,
					const BigInt<256>& staticXor, const int newNum,
					const std::string& privFilename)
{
		
	//std::cout << "In saveOtpFile" << std::endl;
	const std::string padFileContent = generatePadTxtFile(/*pubkey,*/ pad, indexPad, totalPads, generator, thetime, 
		versionNumber, applicationName, generationExtra, accountName, mnemonic, staticXor);
		
	const int numPad = indexPad + 1;
	
	//const std::string privFilename = /*pubkey.toString()*/ getCurrencyShortName() + "_address_"+ intToString(newNum)+ "_private_pad" + intToString(numPad) + ".txt";

	const std::string fullPrivPath = (privPath == ".") ? privFilename : (privPath + "/" + privFilename);
	std::cout << "Saving otp txt : " << withoutLeadingDot(fullPrivPath) << std::endl;
	fileWrite(fullPrivPath, padFileContent);	
}



void savePubOtpTxtFiles(const std::string& filenameBase, 
					const PubAddress& pubkey, 
					const std::string& thetime, 
					const std::string& accountName,
					const std::string pubPath, 
					const std::string& versionNumber, const std::string& applicationName)
{
	//std::cout << "IN savePubOtpTxtFiles: " << staticXor << std::endl;
	
	const std::string privateb58("WIFDUMMY");
	const std::string genMethod("methoddummy");
	const BigInt<256> staticXorDummy;
	const std::list<ExtraInfo> generationExtraDummy;
	const std::string mnemonicDummy;
	const bool compressedDummy(true);
	
	FilePair txtFiles = generateTxtFiles(pubkey, privateb58, genMethod, generationExtraDummy,
					thetime, accountName, mnemonicDummy, compressedDummy,
					versionNumber, applicationName, staticXorDummy);
				
	const std::string pubFilename = filenameBase + "_share.txt";
		
	const std::string fullPubPath = (pubPath == ".") ? pubFilename : (pubPath + "/" + pubFilename);
	std::cout << "Saving pub txt : " << fullPubPath << std::endl;
	fileWrite(fullPubPath, txtFiles.publicFile);	
}



void saveTxtFiles(const int newNum, const PubAddress& pubkey, const std::string privateb58, 
					const std::string& genMethod, const std::list<ExtraInfo>& generationExtra,
					const std::string& thetime, const std::string& accountName,
					const std::string& mnemonic, const bool compressed, const std::string pubPath, const std::string privPath,
					const std::string& versionNumber, const std::string& applicationName,
					const bool isPad, const BigInt<256> staticXor
					)
{
	//std::cout << "IN saveTxtFiles: " << staticXor << std::endl;
	
	FilePair txtFiles = generateTxtFiles(pubkey, privateb58, genMethod, generationExtra,
					thetime, accountName, mnemonic, compressed,
					versionNumber, applicationName, staticXor);
		

	const std::string padExtra = (isPad ? "_pad" : "");
	
	const std::string addressStr = (getCurrencyShortName() == "bch_slp" || getCurrencyShortName() == "bch") ? 
		pubkey.toCashAddrString() : pubkey.toString();
	
	const std::string numStr = (newNum == 0) ? "" : (intToString(newNum) + "_");
	
	const std::string filenameStart = getCurrencyShortName() + "_address_" + numStr + addressStr + padExtra;
	
	const std::string pubFilename = filenameStart + padExtra + "_share.txt";
	const std::string privFilename = filenameStart + padExtra + "_private.txt";

	if(!isPad)
	{
		const std::string fullPrivPath = (privPath == ".") ? privFilename : (privPath + "/" + privFilename);
		std::cout << "Saving priv txt: " << fullPrivPath << std::endl;
		fileWrite(fullPrivPath, txtFiles.privateFile);	
	}
	
	
	const std::string fullPubPath = (pubPath == ".") ? pubFilename : (pubPath + "/" + pubFilename);
	std::cout << "Saving pub txt : " << fullPubPath << std::endl;
	fileWrite(fullPubPath, txtFiles.publicFile);	
}








TxtInfoFile getTxtFiles(const std::string& pubkey, const std::string privateb58, 
					const std::string& genMethod, const std::list<std::string>& generationExtra,
					const std::string& thetime, const std::string& accountName,
					const std::string& mnemonic, const bool compressed,
					const std::string& versionNumber, const std::string& applicationName)
{
	std::string pubTxt;

	pubTxt += "Currency         : ";
	
	const std::string currencyName = getCurrencyName();	
	pubTxt += currencyName;

	pubTxt += "\n";
	
	pubTxt += "Public address   : ";
	pubTxt += pubkey;
	pubTxt += "\n";
	
	pubTxt += "Generated by     : ";
	pubTxt += applicationName;
	pubTxt += " ";	
	pubTxt += versionNumber;
	pubTxt += "\n";
	
	pubTxt += "Generation time  : ";
	pubTxt += thetime;
	pubTxt += "\n";
	if(!accountName.empty())
	{
		pubTxt += "Account name     : ";
		pubTxt += accountName;
		pubTxt += "\n";	
	}

	
	//const std::string pubFilename = pubkey + "_share.txt";
	//std::cout << "Saving pub txt : " << pubFilename << std::endl;
	//fileWrite(pubFilename, pubTxt);	
	
	
	
	std::string privTxt(pubTxt);
	
	privTxt += "Private key (WIF): ";
	privTxt += privateb58;
	privTxt += "\n";
	//privTxt += "Public address   : ";
	//privTxt += pubkey;
	//privTxt += "\n";
	//privTxt += "Generation time  : ";
	//privTxt += thetime;
	//privTxt += "\n";
	privTxt += "Compressed       : ";
	privTxt += (compressed ? "yes" : "no");
	privTxt += "\n";
	
	if(!accountName.empty())
	{
		privTxt += "Account name     : ";
		privTxt += accountName;
		privTxt += "\n";	
	}
	privTxt += "Generation method: ";
	privTxt += genMethod;
	privTxt += "\n";

	privTxt += "Mnemonic         : ";
	privTxt += mnemonic;
	privTxt += "\n";



	for(std::list<std::string>::const_iterator it = generationExtra.begin() ;
		it != generationExtra.end() ;
		++it)
	{
		const std::string& extra = (*it);
		privTxt += extra;
	}

	if(!generationExtra.empty())
	{
		privTxt += "\n";
	}


	const TxtInfoFile fileInfo(pubTxt, privTxt);
	return fileInfo;
	
	//const std::string privFilename = pubkey + "_private.txt";
	//std::cout << "Saving priv txt: " << privFilename << std::endl;
	//fileWrite(privFilename, privTxt);	

}



